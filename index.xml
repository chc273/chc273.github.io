<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Chi&#39;s blog</title>
    <link>https://chc273.github.io/</link>
    <description>Recent content on Chi&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 01 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://chc273.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fitting the parameters in STO-LG</title>
      <link>https://chc273.github.io/posts/2022-01-01-fitting-parameters-in-sto-lg/</link>
      <pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://chc273.github.io/posts/2022-01-01-fitting-parameters-in-sto-lg/</guid>
      <description>Fitting the parameters in STO-LG In computational chemistry, the Slater-type orbital (STO) more accurately describes the qualitative features of the molecular orbitals than Gaussian functions (GF). However, calculating the two-electron integral using STO can be costly. On the other hand, integrating GFs is relatively cheap. One way to solve this problem is to use a linear combination of GFs to approximate a STO. Such linear combination of Gaussian functions is called contracted Gaussian functions (CGF).</description>
      <content:encoded><![CDATA[<h2 id="fitting-the-parameters-in-sto-lg">Fitting the parameters in STO-LG</h2>
<p>In computational chemistry, the Slater-type orbital (STO) more accurately describes the qualitative features of the molecular orbitals than Gaussian functions (GF). However, calculating the two-electron integral using STO can be costly. On the other hand, integrating GFs is relatively cheap. One way to solve this problem is to use a linear combination of GFs to approximate a STO. Such linear combination of Gaussian functions is called <em>contracted Gaussian functions</em> (CGF).</p>
<p>$$\phi_\mu^{CGF}(\vec{r}-\vec{R}_A) = \sum_{p=1}^L d_{p\mu} \phi_p^{GF} (\alpha_{p\mu}, \vec{r} - \vec{R}_A)$$</p>
<p>where <code>L</code> is the length of the contraction, $d_{p\mu}$ and $\alpha_{p\mu}$ are contraction coefficients and contraction exponents, respectively. Hence, the so-called STO-LG strategy uses <code>L</code> Gaussian-type orbitals to approximate one STO function.</p>
<h2 id="approximating-1s-slater-type-function-using-sto-lg">Approximating 1s Slater-type function using STO-LG</h2>
<p>The expressions for 1s STO and GF are</p>
<p>\begin{align}
\phi_{1s}^{STO} (\zeta, \vec{r}) = \left( \frac{\zeta^3}{\pi} \right)^{1/2} e^{-\zeta |\vec{r}-{\vec{R_A}}|} \notag \\
\phi_{1s}^{GF}(\alpha, \vec{r}) = \left(\frac{2\alpha}{\pi}\right)^{3/4} e^{-\alpha |\vec{r}-{\vec{R
_A}}|^2} \notag
\end{align}</p>
<p>where both orbitals have their corresponding parameters. The goal is to find the $d_{p}$ and $\alpha_{p}$ in the following equation</p>
<p>$$
\phi_{1s}^{STO} (\zeta, \vec{r}) = \sum_p^L d_{p}\phi_{1s}^{GF}(\alpha_p, \vec{r})
$$</p>
<h3 id="sto-1g-with-zeta--10">STO-1G with $\zeta = 1.0$</h3>
<p>In the first case, we will show the process of fitting the simplest function STO-1G by assuming $\zeta=1.0$ in the STO. Basically we will solve the following equation for $\alpha_{11}$</p>
<p>$$
\phi_{1s}^{STO} (\zeta=1.0, \vec{r}) = \phi_{1s}^{GF}(\alpha_{11}, \vec{r})
$$</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">zeta</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">a11</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&#34;zeta r alpha a11&#34;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># define the variables</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sto</span> <span class="o">=</span> <span class="p">(</span><span class="n">zeta</span> <span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">zeta</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>  <span class="c1"># general expression for one STO</span>
</span></span><span class="line"><span class="cl"><span class="n">gf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># general expression for one GF</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">sto_1</span> <span class="o">=</span> <span class="n">sto</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># zeta = 1.0</span>
</span></span><span class="line"><span class="cl"><span class="n">gf_1</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">a11</span><span class="p">)</span>  <span class="c1"># alpha = a11</span>
</span></span></code></pre></div><p>Instead of minimize the differences between the two functions, we will maximize the overlap between the GF and the STO following Szabo&rsquo;s book.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">S</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">sto_1</span> <span class="o">*</span> <span class="n">gf_1</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span>  <span class="c1"># the overlap between STO(1.0, r) and GF(alpha, r)</span>
</span></span></code></pre></div><p>We will maximize this overlap in terms of $a_{11}$. Since we will use scipy, we turn the maximization problem into minimzation of the negative of the overlap <code>S</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># function to minimize</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a11</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="n">res</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span></code></pre></div><pre><code>0.2709502078346618
</code></pre>
<p>We get the $\alpha_{11}$ value as 0.2709497296298158. This is almost identical to the result from Szabo&rsquo;s book.</p>
<h4 id="show-the-sto-1g-plot">Show the STO-1G plot</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl"><span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Arial&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">gf_a1</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">gf_1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a11</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&#34;numpy&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">sto_1_np</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">sto_1</span><span class="p">,</span> <span class="s2">&#34;numpy&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">r_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r_np</span><span class="p">,</span> <span class="n">gf_a1</span><span class="p">(</span><span class="n">r_np</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;STO-1G&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r_np</span><span class="p">,</span> <span class="n">sto_1_np</span><span class="p">(</span><span class="n">r_np</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;STO&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&#34;$r$&#34;</span><span class="p">)</span>
</span></span></code></pre></div><pre><code>&lt;matplotlib.text.Text at 0x7fcc2089b898&gt;
</code></pre>
<!-- raw HTML omitted -->
<p>The results are reasonably good.</p>
<h3 id="sto-lg">STO-LG</h3>
<p>We will code the general procedure to calculate $L&gt;1$ CGFs.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span><span class="p">,</span> <span class="n">Math</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_gto</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_symbols</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">ds</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;d:</span><span class="si">{</span><span class="n">L</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">alphas</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;alpha:</span><span class="si">{</span><span class="n">L</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ds</span><span class="p">,</span> <span class="n">alphas</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">STOLG</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">zta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">get_symbols</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">GFs</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_gto</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">GF_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GFs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">gg_int</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GF_sum</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">GF_sum</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">gg_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gg_int</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">sto</span> <span class="o">=</span> <span class="n">sto</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="n">zta</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GF_sum</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sto</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">subs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">alphas</span><span class="p">,</span> <span class="n">x</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">            <span class="n">d0_val</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gg_int</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">subs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">d0_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># print(subs)</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">subs</span> <span class="o">=</span> <span class="n">subs</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          
</span></span><span class="line"><span class="cl">        <span class="c1"># initial guesses</span>
</span></span><span class="line"><span class="cl">        <span class="n">d_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">alpha_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">d_vals</span> <span class="o">+</span> <span class="n">alpha_vals</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nd">@property</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">expr</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">expr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;</span><span class="si">%.6f</span><span class="s2">\phi^</span><span class="si">{GF}</span><span class="s2">(</span><span class="si">%.6f</span><span class="s2">)&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">display</span><span class="p">(</span><span class="n">Math</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">expr</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nd">@property</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GF_sum</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">),</span> <span class="s2">&#34;numpy&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nd">@property</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">[</span><span class="n">lambdify</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">),</span> <span class="s2">&#34;numpy&#34;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">GFs</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;STO-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="si">}</span><span class="s1">G&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">r</span><span class="p">),</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;GF-</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">sto_1_np</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;STO&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</span></span></code></pre></div><h3 id="sto-2g">STO-2G</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">sto2g</span> <span class="o">=</span> <span class="n">STOLG</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">sto2g</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
</span></span></code></pre></div><pre><code>      fun: -0.9984197028799346
 hess_inv: &lt;3x3 LbfgsInvHessProduct with dtype=float64&gt;
      jac: array([ 0.00000000e+00,  2.40918396e-06, -4.10782519e-07])
  message: b'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_&lt;=_PGTOL'
     nfev: 96
      nit: 19
   status: 0
  success: True
        x: array([0.43013353, 0.15162213, 0.85180271])
</code></pre>
<p>The overlap has reached 0.998 with only two GFs.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">sto2g</span><span class="o">.</span><span class="n">expression</span>  
</span></span></code></pre></div><p>$$0.678908\phi^{GF}(0.151622)+0.430134\phi^{GF}(0.851803)$$</p>
<p>The expression above matches with Equation (3.220) in Szabo&rsquo;s book.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">sto2g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r_np</span><span class="p">)</span>
</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="sto-3g">STO-3G</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">sto3g</span> <span class="o">=</span> <span class="n">STOLG</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">sto3g</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
</span></span></code></pre></div><pre><code>      fun: -0.9998347361981794
 hess_inv: &lt;5x5 LbfgsInvHessProduct with dtype=float64&gt;
      jac: array([5.09592368e-06, 1.04027897e-05, 1.17794663e-05, 5.55111512e-06,
       2.22044605e-08])
  message: b'CONVERGENCE: REL_REDUCTION_OF_F_&lt;=_FACTR*EPSMCH'
     nfev: 276
      nit: 39
   status: 0
  success: True
        x: array([0.53532369, 0.15432918, 0.10982016, 0.40578573, 2.22784233])
</code></pre>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">sto3g</span><span class="o">.</span><span class="n">expression</span>
</span></span></code></pre></div><p>$$0.444642\phi^{GF}(0.109820)+0.535324\phi^{GF}(0.405786)+0.154329\phi^{GF}(2.227842)$$</p>
<p>Again the STO-3G expression matches with Equation (3.221) in Szabo&rsquo;s book.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">sto3g</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r_np</span><span class="p">)</span>
</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="summary">Summary</h3>
<p>In this notebook, I show how we can fit the parameters in the contracted Gaussian functions. The results are relatively sensitive to the initial guesses given the optimizers. I believe it will be more so if <code>L</code> further increases.</p>
<p>I also see that with changing $\zeta$, the optimizer gives me results different from the scaling relationships. It will be interesting to further investigate the cause.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Calculating energy of 1D Schrödinger equation using Sympy</title>
      <link>https://chc273.github.io/posts/2021-12-11-sympy-for-hamiltonian/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://chc273.github.io/posts/2021-12-11-sympy-for-hamiltonian/</guid>
      <description>Calculating energy of 1D Schrödinger equation using Sympy I was reading Szabo&amp;rsquo;s book &amp;ldquo;Modern Quantum Chemistry&amp;rdquo; and saw the exercise questions that seem to be solvable via programming. Hence I decided to give it a try and pick up sympy at the same time. I was a mathematica user back in undergrad, but have not used it ever since. Maybe sympy will just do the same trick.
Here is the question (exercise 1.</description>
      <content:encoded><![CDATA[<h2 id="calculating-energy-of-1d-schrödinger-equation-using-sympy">Calculating energy of 1D Schrödinger equation using Sympy</h2>
<p>I was reading Szabo&rsquo;s book &ldquo;Modern Quantum Chemistry&rdquo; and saw the exercise questions that seem to be solvable via programming. Hence I decided to give it a try and pick up <code>sympy</code> at the same time. I was a <code>mathematica</code> user back in undergrad, but have not used it ever since. Maybe <code>sympy</code> will just do the same trick.</p>
<!-- raw HTML omitted -->
<p>Here is the question (exercise 1.18 from the book)</p>
<p><strong>The Schrödinger equation (in atomic units) of an electron moving in one dimension under the influence of the potential $$-\delta(x)$$ is</strong></p>
<p>$$
\left(-\frac{1}{2}\frac{d^2}{dx^2} - \delta(x)\right) | \Phi\rangle = \epsilon | \Phi\rangle
$$</p>
<p><strong>Use the variation method with the trial function</strong></p>
<p>$$
| \tilde \Phi \rangle = N e^{-ax^2}
$$</p>
<p><strong>to show that $$-\pi^{-1}$$ is an upper bound to the exact group state energy (which is -0.5)</strong>.</p>
<!-- raw HTML omitted -->
<p>From the variational principle, we know if the normalized wavefunction satisfies the appropriate boundary condition, then the expectation of the Hamiltonian is an upper bound to the exact ground state energy. In math expressions, if</p>
<p>$$
\langle\tilde\Phi|\tilde\Phi \rangle = 1
$$</p>
<p>then</p>
<p>$$
\langle\tilde\Phi| \mathcal{H} | \tilde\Phi \rangle \ge \epsilon_0
$$</p>
<p>I will show how we can use <code>sympy</code> to solve this problem</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>  <span class="c1"># I dislike this way to import everything, but it seems to be common in sympy</span>
</span></span><span class="line"><span class="cl"><span class="n">init_printing</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&#34;x&#34;</span><span class="p">)</span>  <span class="c1"># define the symbols</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&#34;N a&#34;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># a should be positive to satisfy boundary cond at infinity</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">phi</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># this is our trial function</span>
</span></span></code></pre></div><h3 id="1-normalization-conditions">1. Normalization conditions</h3>
<p>We will need to normalize the wavefunction</p>
<p>$$
\langle\tilde\Phi|\tilde\Phi \rangle = 1
$$</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">phi2_int</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">phi</span> <span class="o">*</span> <span class="n">phi</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">oo</span><span class="p">))</span>  <span class="c1"># the integration of phi * phi. Our function is real here</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">phi2_int</span> 
</span></span></code></pre></div><p>$$\frac{\sqrt{2} \sqrt{\pi} N^{2}}{2 \sqrt{a}}$$</p>
<p>This expression equals to 1 from our normalization condition. Hence we can solve for $$N$$</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">n_cond</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">phi2_int</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">n_cond</span> 
</span></span></code></pre></div><p>$$\left [ \left { N : \frac{\sqrt[4]{2} \sqrt[4]{a}}{\sqrt[4]{\pi}}\right }\right ]$$</p>
<h3 id="2-calculate-the-hamiltonian-with-the-trial-function">2. Calculate the Hamiltonian with the trial function</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">term1</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">phi</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">diff</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">oo</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">term2</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">phi</span> <span class="o">*</span> <span class="n">DiracDelta</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">oo</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">H</span> <span class="o">=</span> <span class="n">term1</span> <span class="o">+</span> <span class="n">term2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">H</span>
</span></span></code></pre></div><p>$$0.25 \sqrt{2} \sqrt{\pi} N^{2} \sqrt{a} - N^{2}$$</p>
<h3 id="3-substitute-the-normalization-condition">3. Substitute the normalization condition</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">H_sol</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">H_sol</span> 
</span></span></code></pre></div><p>$$- \frac{\sqrt{2} \sqrt{a}}{\sqrt{\pi}} + 0.5 a$$</p>
<p>This expression still contains $$a$$. To find the minimum of this equation, we will need to solve for $$a$$</p>
<h3 id="4-minimize-with-respect-to-a">4. Minimize with respect to $$a$$</h3>
<p>$$a$$ is minimal when $$\partial H_{sol}/\partial a = 0$$</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a_sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">H_sol</span><span class="p">,</span> <span class="n">a</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">a_sol</span>
</span></span></code></pre></div><p>$$0.636619772367581$$</p>
<p>substitute $$a$$ solution into the solution for $$H$$, we get</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">H_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="n">a_sol</span><span class="p">})</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
</span></span></code></pre></div><p>$$-0.318309886183791$$</p>
<p>which is exactly $$-\pi^{-1}$$</p>
<p>In summary, in this notebook, I show how we can use <code>sympy</code> to solve simple Schrödinger equation. Sometimes, using <code>sympy</code> can be unintuitive especially if the bounds of the variables are not properly set. In that case, you will get piecewise function results, and you will need to manually select the correct solutions.</p>
<p>I found the use of expression <code>oo</code> to represent infinity quite interesting and brilliant.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Speed comparison among numpy, cython, numba and tensorflow 2.0</title>
      <link>https://chc273.github.io/posts/2019-10-04-speed-comparison-among-numpy-cython-numba-and-tensorflow/</link>
      <pubDate>Fri, 04 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://chc273.github.io/posts/2019-10-04-speed-comparison-among-numpy-cython-numba-and-tensorflow/</guid>
      <description>Speed comparison among numpy, cython, numba and tensorflow 2.0 Recently I have been working on speeding up some codes in pymatgen for finding the atomic neighbors within a cutoff radius. I was searching online and found that cython is a rather powerful tool for accelerating python loops, and decided to give it a try.
A common comparison for cython is numba and I have heard many good things about it. A less common competitor is the recently released tensorflow 2.</description>
      <content:encoded><![CDATA[<h2 id="speed-comparison-among-numpy-cython-numba-and-tensorflow-20">Speed comparison among numpy, cython, numba and tensorflow 2.0</h2>
<p>Recently I have been working on speeding up some codes in pymatgen for finding the atomic neighbors within a cutoff radius. I was searching online and found that <code>cython</code> is a rather powerful tool for accelerating python loops, and decided to give it a try.</p>
<p>A common comparison for <code>cython</code> is <code>numba</code> and I have heard many good things about it. A less common competitor is the recently released <code>tensorflow 2.0</code>. In fact, back in the <code>tensorflow 1.x</code> era, I did some simple comparisons and found that the speed was in fact faster than <code>numpy</code>. The new <code>tensorflow 2.0</code> is boasted to be 3x faster than <code>tensorflow 1.x</code>, and it makes me wonder how faster would <code>tensorflow 2.0</code> be for some simple computing tasks.</p>
<h3 id="function-decorate-to-record-time">Function decorate to record time</h3>
<p>I like to do simple things myself so that I know what exactly happens in the code. So I am writing a timeit decorator instead of using <code>timeit</code> package.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">functools</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">timeit</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Decorator to run function n times and print out the total time elapsed.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">dec</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> iterated </span><span class="si">%d</span><span class="s2"> times</span><span class="se">\n</span><span class="s2">Time elapsed </span><span class="si">%.3f</span><span class="s2">s</span><span class="se">\n</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">wrapped</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dec</span>
</span></span></code></pre></div><h3 id="computing-functions-using-different-methods">Computing functions using different methods</h3>
<p>Here I am computing</p>
<p>\[matrix[i, j] = i^2 + j^2\]</p>
<p>for a matrix of size <code>[m, n]</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># import numba, tensorflow and numpy, load cython</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numba</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">%</span><span class="n">load_ext</span> <span class="n">cython</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nd">@tf.function</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">compute_tf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tracing &#39;</span><span class="p">,</span>  <span class="n">m</span><span class="p">,</span>  <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">x1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="n">x2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">x2</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">compute_tf</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># trace once</span>
</span></span></code></pre></div><pre><code>Tracing  Tensor(&quot;m:0&quot;, shape=(), dtype=int32) Tensor(&quot;n:0&quot;, shape=(), dtype=int32)
&lt;tf.Tensor: id=261, shape=(0, 0), dtype=int32, numpy=array([], shape=(0, 0), dtype=int32)&gt;
</code></pre>
<p>I used the <code>tf.function</code> decorate to define the graph and avoided repeated tracing the graph by using <code>tf.constant</code> as input and perform the initial graph tracing. You will see that running this function will not invoke the <code>print</code> function. It is only traced once</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">compute_numpy</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">x2</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nd">@numba.njit</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">compute_numba</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span>  <span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">compute_numba</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># JIT compile first</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nd">@numba.njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">compute_numba_parallel</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numba</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">numba</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span>  <span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="n">compute_numba_parallel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># JIT compile first</span>
</span></span></code></pre></div><pre><code>array([[0.]])
</code></pre>
<p>Numpy and numba are almost the same. <code>numba</code> is really handy in terms of turning on parallel computations.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">%%</span><span class="n">cython</span>
</span></span><span class="line"><span class="cl"><span class="n">cimport</span> <span class="n">cython</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl"><span class="n">cimport</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
</span></span><span class="line"><span class="cl"><span class="nd">@cython.boundscheck</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nd">@cython.wraparound</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">compute_cython</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">cdef</span> <span class="n">long</span> <span class="p">[:,</span> <span class="p">::</span><span class="mi">1</span><span class="p">]</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">cdef</span> <span class="nb">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">j</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span>
</span></span></code></pre></div><p><code>cython</code> needs more work and i am delegating the memory management to <code>numpy</code> here and use <code>memoryview</code> x. Basically it is like <code>C</code>. Note that <code>cython</code> can also turn on parallel computations like <code>numba</code> by using <code>cython.parallel.prange</code>. However it does require <code>openmp</code>, which does not ship with <code>clang</code> compiler in macos. So I am not testing the parallel version here.</p>
<h3 id="results">Results</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">m</span> <span class="o">=</span> <span class="mi">2000</span>
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="mi">10000</span>
</span></span><span class="line"><span class="cl"><span class="n">n_loop</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">timeit</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_loop</span><span class="p">)(</span><span class="n">compute_numpy</span><span class="p">)(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">timeit</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_loop</span><span class="p">)(</span><span class="n">compute_numba</span><span class="p">)(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">timeit</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_loop</span><span class="p">)(</span><span class="n">compute_numba_parallel</span><span class="p">)(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">timeit</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_loop</span><span class="p">)(</span><span class="n">compute_cython</span><span class="p">)(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">timeit</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_loop</span><span class="p">)(</span><span class="n">compute_tf</span><span class="p">)(</span><span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span></span></code></pre></div><pre><code>compute_numpy iterated 10 times
Time elapsed 0.971s

compute_numba iterated 10 times
Time elapsed 1.110s

compute_numba_parallel iterated 10 times
Time elapsed 0.651s

compute_cython iterated 10 times
Time elapsed 1.098s

compute_tf iterated 10 times
Time elapsed 0.190s
</code></pre>
<h3 id="conclusion">Conclusion</h3>
<p><code>Tensorflow 2.0</code> is amazing.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
